<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Eksplorasi Jasmine</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link  rel="stylesheet" href="/assets/style.css" /><link  rel="stylesheet" href="/assets/monokai.css" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/semantic-ui/0.3.4/css/semantic.min.css">
</head>
<body>
<div class="ui red vertical sidebar menu" style="display:block;margin-left: 0!important;">

    <div class="item">
        <b>Belajar Jasmine</b>
        <div class="menu">
            
                <a href="/posts/async.html" class="item">Pengujian Asynchronous</a>
            
                <a href="/posts/matamata.html" class="item">Mata mata</a>
            
                <a href="/posts/pengantar.html" class="item">Pengantar</a>
            
                <a href="/posts/pengantarfungsi.html" class="item">Eksplorasi Jasmine</a>
            
                <a href="/posts/persiapan.html" class="item">Persiapan</a>
            
                <a href="/posts/plugin.html" class="item">Jasmine Plugin</a>
            
        </div>
    </div>

</div>

<div id="content">
    <h2>Eksplorasi fungsi-fungsi Jasmine</h2>
<p>Mari kita jalankan <strong>testem</strong> dengan mengetikkan perintah di bawah ini pada console:</p>
<blockquote>
<p>testem</p>
</blockquote>
<p>Karena kami telah menetapkan bahwa kami ingin menguji kode kami pada browser Firefox, maka <strong>testem</strong> secara otomatis akan menjalankan Firefox. Hasilnya adalah sebagai berikut:</p>
<p><img src="pics/testem-firefox.jpeg" alt=""></p>
<p>Kita belum menuliskan kode apapun. Sehingga belum ada kode yang dapat dites. Mari kita tuliskan test pertama kita. Buatlah sebuah berkas pada alamat <code>code/specs/vector2dSpec.js</code>. Pada berkas tersebut, mari kita tuliskan kode test pertama kita.</p>
<pre><code>describe(&quot;Vector2d&quot;, function(){
    it(&quot;Should have an add property&quot;, function(){
        expect(vector2d.add).toBeDefined();
    });
});</code></pre>
<p>Jadi, <code>describe</code> menunjukkan sebuah <strong>test suite</strong>. <strong>Test Suite</strong> ini semacam kelompok besar dari sebuah test. Jadi, pada contoh di atas, kita memiliki sebuah <strong>test suite</strong> mengenai module <code>Vector2d</code>. Kita bisa menentukan nama lain dari <strong>test suite</strong> tersebut. Misalnya:</p>
<pre><code>describe(&quot;Uji coba Vector2d&quot;, function(){

});</code></pre>
<p>Di dalam sebuah <strong>test suite</strong>, kita memiliki <strong>specs</strong>. Disinilah kode testing kita tuliskan. Pada contoh di atas, kita memiliki sebuah <strong>specs</strong>, dimana kita mengharapkan bahwa sebuah objek <code>vector2d</code> memiliki sebuah properti <code>add</code>. Bila kita menyimpan kode di atas, maka tampilan dari browser kita sudah berubah:</p>
<p><img src="pics/testem-ontest.jpeg" alt=""></p>
<p>Mari kita lihat peringatannya:</p>
<pre><code>ReferenceError: vector2d is not defined in http://localhost:7357/specs/vector2dSpec.js (line 3)</code></pre>
<p>Jasmine memberitahukan kepada kita bahwa objek vector2d belum terdefinisikan. Ini sudah jelas, kita belum menuliskan kode vector2d yang hendak kita test. Ayo kita tulis module tersebut. Kita simpan module vector2d pada alamat <code>code/src/vector2d.js</code>:</p>
<pre><code>(function(global){
    var vector2d = {

    };

    global.vector2d = vector2d;
}(window));</code></pre>
<p>Pada code di atas, kita memperkenalkan objek vector2d pada <strong>global objek</strong>. Pendekatan ini hanyalah contoh. Pada project sebenarnya, bisa jadi kita menggunakan suatu <strong>namespace</strong> tertentu, ataupun menggunakan mekanisme module lainnya. Tetapi pada contoh ini, tujuan utamanya adalah bagaimana agar objek <code>vector2d</code> dapat dikenali oleh kode test kita.</p>
<p>Ketika kita menyimpan kode di atas, maka tampilan browser akan berubah. Kita memperoleh pesan error baru:</p>
<pre><code>Expected undefined to be defined.</code></pre>
<p>Mari kita bandingkan pesan error di atas dengan kode test kita:</p>
<pre><code>expect(vector2d.add).toBeDefined();</code></pre>
<p>Hampir mirip bukan? Namun kode test di atas membangkitkan error karena <code>vector2d.add</code> belum terdefinisikan. Oleh jamine, <code>vector2d.add</code> bernilai <code>undefined</code>. Padahal kita menginginkan <code>vector2d.add</code> sudah terdefinisikan.</p>
<p>Ayo kita tambahkan properti add pada objek <code>vector2d</code>:</p>
<pre><code>(function(global){
    var vector2d = {
        add: &quot;&quot;
    };

    global.vector2d = vector2d;
}(window));</code></pre>
<p>Ketika kode di atas kita simpan, kita memperoleh tanda bahwa kode module <code>vector2d</code> sudah lolos uji coba:</p>
<p><img src="pics/testem-passed.jpeg" alt=""></p>
<p>Sekarang mari kita buat kode test baru. Seiring kita membuat test, kita juga akan menambahkan kode pada module <code>vector2d</code> kita.</p>
<p>Misalnya kita ingin memeriksa bahwa <code>add</code> pada <code>vector2d</code> adalah sebuah <code>function</code>. Maka, kode testnya adalah sebagai berikut:</p>
<pre><code>describe(&quot;Vector2d&quot;, function(){
    it(&quot;Should have an add property&quot;, function(){
        expect(vector2d.add).toBeDefined();
    });

    it(&quot;Should have an add property which has the typeof function&quot;, function(){
        expect(typeof vector2d.add).toEqual(&quot;function&quot;);
    });
});</code></pre>
<p>Dan ketika kita simpan kode di atas, kita akan memperoleh tanda merah:</p>
<p><img src="pics/testem-expected-function.jpeg" alt=""></p>
<p>Ok, masalahnya adalah, properti <code>add</code> pada objek <code>vector2d</code> adalah sebuah string, bukan fungsi. Jadi jelaslah jasmine membangkitkan kode di atas. Mari kita perbaiki module <code>vector2d</code> kita:</p>
<pre><code>(function(global){
    var vector2d = {
        add: function(){

        }
    };

    global.vector2d = vector2d;
}(window));</code></pre>
<p>Dan ketika kita simpan, warna hijau muncul kembali. :D</p>
<p><img src="pics/testem-typeof-function.jpeg" alt=""></p>
<p>Ok, pada titik ini, kita sudah berkenalan dengan lima kata kunci pada Jasmine, yaitu <code>describe</code>, <code>it</code>, <code>expect</code>, <code>toBeDefined</code>, dan <code>toBe</code>. Jasmine masih menyediakan banyak fungsi lainnya yang bertujuan untuk memudahkan penulisan kode test kita.</p>
<p>Sekarang saatnya kita menguji apakah <code>vector2d.add()</code> akan mengembalikan jawaban sesaui dengan harapan kita. Bila kita menambahkan dua buah vektor, <code>v1</code> dan <code>v2</code>, dimana pada tiap vektor, terdapat properti <code>x</code> dan <code>y</code>, maka kita juga mengharapkan metode <code>vector2d.add()</code> mengembalikan jawaban berupa sebuah objek dengan properti <code>x</code> dan <code>y</code> pula.</p>
<p>Jadi, misal:</p>
<pre><code>var v1 = {
        x: 20,
        y: 30
    },
    v2 = {
        x: 5,
        y: 1
    };</code></pre>
<p>Maka, bila kedua objek di atas dijumlahkan, seharusnya hasilnya adalah sebuah objek dengan properti <code>x</code> bernilai <code>25</code>, dan <code>y</code> bernilai <code>31</code>.</p>
<p>Untuk memastikan hal tersebut, mari kita buat testnya terlebih dahulu. Kita akan melakukannya secara bertahap. Pertama, kita periksa bahwa nilai yang dikembalikan oleh metode <code>add</code> memiliki properti <code>x</code> dan <code>y</code>:</p>
<pre><code>it(&quot;Add method should return an object with property x and y&quot;, function(){
    var v1 = { x: 20, y: 30},
        v2 = { x: 5, y: 1};

    expect(vector2d.add(v1, v2).hasOwnProperty(&quot;x&quot;)).toBeTruthy();
});</code></pre>
<p>Apa yang terjadi ketika kita menyimpan kode test di atas?</p>
<p><img src="pics/testme-add-return.jpeg" alt=""></p>
<p>Ok, kita memang belum mengembalikan apapun ketika metode <code>add</code> dijalankan (perhatikan <strong>TypeError: vector2d.add(...) is undefined</strong>). Mari kita buat kode secukupnya agar kode test kita berwarna hijau:</p>
<pre><code>var vector2d = {
    add: function(){
        return {x: 0, y: 0};
    }
};</code></pre>
<p>Hasilnya? Hijau.</p>
<p><img src="pics/testme-add-return-passed.jpeg" alt=""></p>
<p>Sekarang saatnya memeriksa apakah kembalian dari metode <code>add</code> bernilai benar.</p>
<pre><code>it(&quot;Add method should return the correct answer&quot;, function(){
    var v1 = { x: 20, y: 30},
        v2 = { x: 5, y: 1};

    expect(vector2d.add(v1, v2)).toEqual({x: 25, y: 31});
});</code></pre>
<p>Namun, kode test di atas akan menghasilkan:</p>
<p><img src="pics/testme-add-return-value-failed.jpeg" alt=""></p>
<p>Perhatikan bagaimana jasmine memberitahukan kepada kita, kesalahan yang berhasil ditangkap oleh kode test terhadap module <code>vector2d</code>. Ketika kita mengharapkan kembalian berupa <code>{x: 25, y: 31}</code>, metode <code>add</code> malah mengembalikan <code>{x: 0, y: 0}</code>. Jelas bukan pesan errornya?</p>
<p>Saatnya memperbaiki metode <code>add</code>:</p>
<pre><code>var vector2d = {
    add: function(v1, v2){
        return {x: v1.x + v2.x , y: v1.y + v2.y};
    }
};</code></pre>
<p>Dan, yap, hasilnya hijau:</p>
<p><img src="pics/testme-add-return-value-passed.jpeg" alt=""></p>
<p>Ok, sampai disini semoga kita dapat melihat bagaiman <strong>testem</strong> telah memudahkan kita dalam menggunakan jasmine. Kita dapat memperoleh hasil dari testing secara langsung dan otomatis tiap kali kode kita mengalami perubahan.</p>
<p>Jangan lupa juga, bahwa <strong>testem</strong> juga melaporkan progress test kita pada console dimana command <strong>testem</strong> dijalankan:</p>
<p><img src="pics/testem-test-progress-4tests.jpeg" alt=""></p>
<h3>Menstrukturkan Test Suite</h3>
<p>Kita dapat terus melanjutkan untuk menambahkan <strong>specs</strong> pada test kita sebelumnya. Namun ada suatu pendekatan yang dapat memudahkan kita dalam hal penstrukturan test.</p>
<p>Misal, pada kode test yang sudah ada saat ini, kita mengetahui bahwa kita sedang melakukan pengujian terhadap metode <code>add</code> yang dimiliki oleh <code>vector2d</code>. Bagaimana kalau kita mengelompokkan seluruh pengujian terhadap <code>add</code> di dalam sebuah kelompok sendiri?</p>
<p>Caranya adalah dengan menggunakan <code>describe</code>:</p>
<pre><code>describe(&quot;Vector2d&quot;, function(){
    describe(&quot;Add method&quot;, function(){
        it(&quot;Should have an add property&quot;, function(){
            expect(vector2d.add).toBeDefined();
        });

        it(&quot;Should have an add property which has the typeof function&quot;, function(){
            expect(typeof vector2d.add).toEqual(&quot;function&quot;);
        });

        it(&quot;Add method should return an object with property x and y&quot;, function(){
            var v1 = { x: 20, y: 30},
                v2 = { x: 5, y: 1};

            expect(vector2d.add(v1, v2).hasOwnProperty(&quot;x&quot;)).toBeTruthy();
        });

        it(&quot;Add method should return the correct answer&quot;, function(){
            var v1 = { x: 20, y: 30},
                v2 = { x: 5, y: 1};

            expect(vector2d.add(v1, v2)).toEqual({x: 25, y: 31});
        });
    });
});</code></pre>
<p>Tampilan jasmine kita juga mengalami perubahan:</p>
<p><img src="pics/testem-group.jpeg" alt=""></p>
<h3>Matchers Lainnya</h3>
<p>Metode seperti <code>toEqual</code>, <code>toBeDefined</code>, <code>toBeTruthy</code> yang sudah kami perlihatkan di atas adalah contoh dari <strong>matchers</strong>. Jasmine memiliki <strong>matchers</strong> lainnya yang dapat digunakan untuk menguji kode yang kita tulis.</p>
<p>Beberepa <strong>matcher</strong> lain yang disediakan oleh Jasmine adalah sebagai berikut:</p>
<p><strong>toBe</strong></p>
<pre><code>expect(true).toBe(true);
expect(false).not.toBe(true);</code></pre>
<p><strong>toMatch</strong> : pemeriksaan berdasarkan Regular Expression</p>
<pre><code>expect(someString).toMatch(/foo/);
expect(someString).not.toMatch(/baar/);</code></pre>
<p><strong>toBeNull</strong></p>
<pre><code>expect(null).toBeNull();</code></pre>
<p><strong>toContain</strong></p>
<pre><code>var kota = [&quot;Surabaya&quot;, &quot;Malang&quot;, &quot;Jakarta&quot;];

expect(kota).toContain(&quot;Malang&quot;);
expect(kota).not.toContain(&quot;Bandung&quot;);</code></pre>
<h3>beforeEach dan afterEach</h3>
<p>Bila kita ingin menjalankan suatu metode atau langkah-langkah tertentu sebelum setiap <strong>spec</strong> dijalankan, kita dapat memanfaatkan <code>beforeEach</code>. Sementara itu, bila kita ingin menjalankan suatu langkah tertentu setelah tiap <strong>specs</strong> selesai dijalankan, kita dapat menggunakan <code>afterEach</code>. Contoh:</p>
<pre><code>describe(&quot;Substract method&quot;, function(){
    var v1, v2;

    beforeEach(function(){
        v1 = {x: 20, y: 30};
        v2 = {x: 5, y: 50};
    });

    afterEach(function(){
        v1 = v2 = null;
    });

    it(&quot;Should substract properly&quot;, function(){
        expect(vector2d.substract(v1, v2)).toEqual({x: 15, y: -20});
    });

    it(&quot;Should only have x and y as direct properties&quot;, function(){
        var result = vector2d.substract(v1, v2);

        // memeriksa sesuatu bernilai undefined
        expect(result.a).toBeUndefined();

        // berikut ini sama saja dengan bentuk di atas
        expect(result.a).not.toBeDefined();
    });

    it(&quot;Should have no problem working with PI&quot;, function(){
        var test = {x: 5, y: Math.PI}, // Math.PI = 3.14.... sekian sekian
            result = vector2d.substract(v1, test);

        expect(result.y).toBeGreaterThan(26); // lebih besar dari 26
        expect(result.y).toBeLessThan(27); // kurang dari 27

        expect(result.y).toBeCloseTo(26.85, 1);
    });
});</code></pre>
<p>Pada contoh di atas, sebelum tiap <strong>spec</strong> dijalankan, kita memberikan nilai kepada variabel <code>v1</code> dan <code>v2</code>. Tiap kali <strong>specs</strong> dijalankan, <code>v1</code> dan <code>v2</code> bernilai sesuai dengan nilai yang diberikan ketika <code>beforeEach</code> dijalankan.</p>
<p>Ketika tiap <strong>specs</strong> sudah dijalankan, kita me-null-kan kembali <code>v1</code> dan <code>v2</code>.</p>

</div>

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/semantic-ui/0.3.4/javascript/semantic.min.js"></script>

<script defer="defer"  src="/scripts/script.js"></script>
</body>
</html>